/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository on manifest.json
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LiquidLockPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// LockScreen.ts
var LockScreen = class {
  constructor(app, checkPinCallback) {
    this.overlay = null;
    this.currentPinInput = "";
    this.isLocked = false;
    this.app = app;
    this.checkPinCallback = checkPinCallback;
  }
  lock() {
    if (this.isLocked)
      return;
    this.isLocked = true;
    this.render();
  }
  render() {
    this.currentPinInput = "";
    this.remove();
    this.overlay = document.body.createEl("div", { cls: "liquid-lock-overlay" });
    this.overlay.createEl("div", { cls: "liquid-lock-bg-anim" });
    const container = this.overlay.createEl("div", { cls: "liquid-lock-glass-container" });
    container.createEl("h2", { text: "Locked", cls: "liquid-lock-title" });
    const pinDisplay = container.createEl("div", { cls: "liquid-lock-pin-display" });
    const dots = [];
    for (let i = 0; i < 4; i++) {
      dots.push(pinDisplay.createEl("div", { cls: "liquid-lock-pin-dot" }));
    }
    const messageEl = container.createEl("div", { cls: "liquid-lock-message" });
    const numpad = container.createEl("div", { cls: "liquid-lock-numpad" });
    const chars = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "", "0", "DEL"];
    chars.forEach((char) => {
      if (char === "") {
        numpad.createEl("div");
        return;
      }
      const btn = numpad.createEl("button", { cls: "liquid-lock-num-btn", text: char === "DEL" ? "\u232B" : char });
      btn.onclick = (e) => {
        e.stopPropagation();
        this.handleInput(char, dots, messageEl, container);
      };
    });
    this.overlay.onkeydown = (e) => {
      e.stopPropagation();
      if (e.key >= "0" && e.key <= "9") {
        this.handleInput(e.key, dots, messageEl, container);
      } else if (e.key === "Backspace" || e.key === "Delete") {
        this.handleInput("DEL", dots, messageEl, container);
      }
    };
    this.overlay.tabIndex = 0;
    this.overlay.focus();
  }
  handleInput(char, dots, messageEl, container) {
    if (char === "DEL") {
      this.currentPinInput = this.currentPinInput.slice(0, -1);
    } else {
      if (this.currentPinInput.length < 4) {
        this.currentPinInput += char;
      }
    }
    dots.forEach((dot, index) => {
      if (index < this.currentPinInput.length) {
        dot.addClass("filled");
      } else {
        dot.removeClass("filled");
      }
    });
    if (this.currentPinInput.length === 4) {
      setTimeout(() => {
        if (this.checkPinCallback(this.currentPinInput)) {
          this.unlock();
        } else {
          container.addClass("liquid-lock-shake");
          messageEl.innerText = "Incorrect PIN";
          this.currentPinInput = "";
          dots.forEach((d) => d.removeClass("filled"));
          setTimeout(() => {
            container.removeClass("liquid-lock-shake");
            messageEl.innerText = "";
          }, 500);
        }
      }, 100);
    }
  }
  unlock() {
    this.isLocked = false;
    this.remove();
  }
  remove() {
    if (this.overlay) {
      this.overlay.remove();
      this.overlay = null;
    }
  }
  isLockedState() {
    return this.isLocked;
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  pin: "1234",
  timeoutMinutes: 5,
  blurContent: true,
  autoLockOnStart: true
};
var LiquidLockPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.idleTimer = null;
    this.lastActivityTime = Date.now();
  }
  async onload() {
    await this.loadSettings();
    this.lockScreen = new LockScreen(this.app, (pin) => this.checkPin(pin));
    this.addSettingTab(new LiquidLockSettingTab(this.app, this));
    this.registerDomEvent(document, "mousemove", () => this.resetIdleTimer());
    this.registerDomEvent(document, "keydown", () => this.resetIdleTimer());
    this.registerDomEvent(document, "scroll", () => this.resetIdleTimer());
    this.registerDomEvent(document, "click", () => this.resetIdleTimer());
    this.registerDomEvent(window, "blur", () => {
    });
    this.checkIdleInterval();
    this.app.workspace.onLayoutReady(() => {
      if (this.settings.autoLockOnStart) {
        this.lock();
      }
    });
    this.addCommand({
      id: "lock-obsidian",
      name: "Lock Obsidian",
      callback: () => {
        this.lock();
      }
    });
    this.addCommand({
      id: "debug-media-state",
      name: "Debug Media State (Check Console)",
      callback: () => {
        console.log("--- Liquid Lock Debug Media ---");
        if ("mediaSession" in navigator) {
          console.log("MediaSession State:", navigator.mediaSession.playbackState);
        } else {
          console.log("MediaSession API not supported");
        }
        console.log("Checking Workspace Leaves:");
        this.app.workspace.iterateAllLeaves((leaf) => {
          const viewType = leaf.view.getViewType();
          console.log(`- Leaf View Type: ${viewType}`);
          if (viewType.includes("media") || viewType.includes("video") || viewType.includes("bilibili")) {
            console.log(`  - Potential Media Leaf found: ${viewType}`);
            const container = leaf.view.contentEl;
            const vids = container.querySelectorAll("video");
            const ifrs = container.querySelectorAll("iframe");
            const webviews2 = container.querySelectorAll("webview");
            console.log(`  - Content: ${vids.length} videos, ${ifrs.length} iframes, ${webviews2.length} webviews`);
          }
        });
        const playingClasses = [".plyr--playing", ".is-playing", ".media-playing", ".active-media"];
        playingClasses.forEach((cls) => {
          const el = document.querySelector(cls);
          if (el)
            console.log(`Class '${cls}' FOUND.`, el);
        });
        const videos = document.querySelectorAll("video");
        const iframes = document.querySelectorAll("iframe");
        const webviews = document.querySelectorAll("webview");
        console.log(`Global Search: ${videos.length} videos, ${iframes.length} iframes, ${webviews.length} webviews.`);
        console.log("isMediaPlaying() returns:", this.isMediaPlaying());
        console.log("--- End Debug ---");
      }
    });
    console.log("Liquid Lock Plugin loaded");
  }
  checkIdleInterval() {
    this.registerInterval(window.setInterval(async () => {
      if (this.lockScreen.isLockedState())
        return;
      if (this.isMediaPlaying()) {
        console.log("Liquid Lock: DOM Media playing detected.");
        this.resetIdleTimer();
        return;
      }
      if (await this.checkWebviews()) {
        console.log("Liquid Lock: Webview Media playing detected.");
        this.resetIdleTimer();
        return;
      }
      const timeSinceLastActivity = Date.now() - this.lastActivityTime;
      const timeoutMs = this.settings.timeoutMinutes * 60 * 1e3;
      if (timeSinceLastActivity > timeoutMs) {
        this.lock();
      }
    }, 1e3 * 10));
  }
  resetIdleTimer() {
    this.lastActivityTime = Date.now();
  }
  async checkWebviews() {
    const webviews = document.querySelectorAll("webview");
    for (let i = 0; i < webviews.length; i++) {
      const wv = webviews[i];
      try {
        const isPlaying = await wv.executeJavaScript(`
                    (function() {
                        const media = document.querySelectorAll('video, audio');
                        for(let i=0; i<media.length; i++) {
                            if(!media[i].paused && !media[i].ended) return true;
                        }
                        return false;
                    })()
                `);
        if (isPlaying)
          return true;
      } catch (e) {
      }
    }
    return false;
  }
  isMediaPlaying() {
    if ("mediaSession" in navigator && navigator.mediaSession.playbackState === "playing") {
      return true;
    }
    const playingClasses = [".plyr--playing", ".is-playing", ".media-playing", ".active-media"];
    if (document.querySelector(playingClasses.join(","))) {
      return true;
    }
    const scanForMedia = (root) => {
      try {
        const mediaElements = root.querySelectorAll("video, audio");
        for (let i = 0; i < mediaElements.length; i++) {
          const media = mediaElements[i];
          if (!media.paused && !media.ended) {
            return true;
          }
        }
        const allElements = root.querySelectorAll("*");
        for (let i = 0; i < allElements.length; i++) {
          const el = allElements[i];
          if (el.shadowRoot) {
            if (scanForMedia(el.shadowRoot))
              return true;
          }
        }
        const iframes = root.querySelectorAll("iframe");
        for (let i = 0; i < iframes.length; i++) {
          try {
            const doc = iframes[i].contentDocument;
            if (doc && scanForMedia(doc))
              return true;
          } catch (e) {
          }
        }
      } catch (err) {
        console.error("Liquid Lock: Error scanning media", err);
      }
      return false;
    };
    return scanForMedia(document);
  }
  lock() {
    if (!this.lockScreen.isLockedState()) {
      this.lockScreen.lock();
    }
  }
  checkPin(pin) {
    return pin === this.settings.pin;
  }
  onunload() {
    this.lockScreen.remove();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var LiquidLockSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Liquid Lock Settings" });
    new import_obsidian.Setting(containerEl).setName("PIN Code").setDesc("Set the 4-digit PIN to unlock Obsidian.").addText((text) => text.setPlaceholder("1234").setValue(this.plugin.settings.pin).onChange(async (value) => {
      this.plugin.settings.pin = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto-Lock Timeout (Minutes)").setDesc("Lock after N minutes of inactivity.").addText((text) => text.setPlaceholder("5").setValue(String(this.plugin.settings.timeoutMinutes)).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num)) {
        this.plugin.settings.timeoutMinutes = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Auto-Lock on Start").setDesc("Automatically lock Obsidian when it starts.").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoLockOnStart).onChange(async (value) => {
      this.plugin.settings.autoLockOnStart = value;
      await this.plugin.saveSettings();
    }));
  }
};
